# OWTP协议框架设计

[TOC]

## 修订信息

| 版本  | 时间       | 修订人 | 修订内容 |
|-------|------------|--------|----------|
| 1.0.0 | 2018-07-04 | 麦志泉 | 创建文档 |

---

## 1 概述

OWTP协议全称OpenWallet Transfer Protocol，是一种基于点对点的分布式通信协议。
OWTP协议最初概念是来自《OpenWallet商户接口》的业务接口实现。
为了保证钱包客户端与商户服务安全稳定地通信。我们有以下安全需求：

1. 钱包客户端不暴露任何端口给内外网，钱包始终只连接它的区块链点对点网络，这样保证了钱包服务器不会被黑入。
2. 需要实现商户服务端和钱包客户端都能主动向对方发送请求。
3. 商户服务端用户量非常大，钱包客户端能够部署可扩容的服务器，分布式存储与用户相关的钱包数据。

基于以上需求，我们抽象出来设计了OWTP协议。它能够提供以下功能：

1. 只要有一端发起了连接，两端就可以实现像HTTP一样的请求响应通信模式。
2. 基于点对点的底层通信协议，节点能够提供对等的功能，即充当客户端，也充当服务端。
3. 基于节点的对等功能实现，部署大量节点可构建去中心化的分布式网络。
4. 节点之间的通信支持自定义的授权规则，数据的加解密规则。

## 2 框架设计需求

| 需求                     | 描述                                                                              |
|--------------------------|-----------------------------------------------------------------------------------|
| 基于TCP/IP的长连接实现   | 可以基于websocket，自定义的socket等， 包含主动连接和监听连接                                                   |
| 数据包定义与序列实现     | 根据OWTP协议实现数据包序列化                                                      |
| 多路复用路由器实现       | 实现一个路由器，可以调用者绑定业务方法，内部处理业务方法的路由                      |
| 消息上下文实现           | 实现一个上下文结构，能够在路由过程中给业务方法更新状态                             |
| 请求实现                 | 实现向对方节点发起业务方法请求                                                    |
| 请求队列实现             | 实现一个请求队列，能够处理异步和同步请求操作，并能够定时检查超时的请求，做出超时响应 |
| 连接状态的结果回调       | 在连接发生后，连上，断开的状态能够回调给节点的代理方法                              |
| 重放攻击防御             | 能够有序生成nonce，过滤重放的请求。                                                 |
| 自定义的授权与加解密规则 | 实现授权接口，处理自定义的授权和数据加解密规则                                     |

## 3 通信协议约定

- 底层连接采用websocket协议，这样可以省去处理粘包和半包的问题。
- 通过SM2的数字签名技术，协商技术保证数据的正确性和私密性。
- 建立连接通道后，传输内容以json格式编码，两端按照约定规范模型进行交互。

### 3.1 安全规则

- 发起连接方的节点A，本地生成SM2密钥对。
- 连接时带参数：公钥，随机nonce，时间戳，及把前者sha256两次后用私钥签名。
- 被连节点B收到参数后，校验公钥是否来自第三方机构已登记可信任节点，并验证签名，验证请求是否重放。
- A与B连接成功，B收到的A公钥基于SM2的协商机制，动态计算一个密钥，用于通信过程加密，并把协商结果发给A。
- B收到协商结果，本地也进行计算相关的密钥，验证协商结果，把他的协商结果返回给A。
- 相关协商通过后，双方基于对称加密通信方式进行正常的业务交互。不通过，A与B应该主动断开。

- 商户端和钱包端都必须在本机内通过ECC算法生成密钥对。
- 钱包管理工具部署商户SDK公钥，作为验签的识别对象。
- 商户SDK登记钱包端公钥，作为验签的识别对象。

### 3.2 建立连接

`连接入口`

ws://server.com/openw/s/v1

`请求参数`

| 参数名称 | 类型   | 是否可空   | 描述                                                                              |
|----------|--------|------------|-----------------------------------------------------------------------------------|
| a        | string | 是         | 本节点公钥                                                                        |
| n        | uint32 | 123        | 请求序号。为了保证请求对应响应按序执行，并防御重放攻击，序号可以为随机数，但不可重复。 |
| t        | uint32 | 1528520843 | 时间戳。限制请求在特定时间范围内有效，如10分钟。                                     |
| c        | string | 是         | 协商生成的密钥类别，aes-128-ctr，aes-128-cbc，aes-256-ecb等                          |
| s        | string | 是         | 组合[a+n+t]并sha256两次，使用钱包工具配置的本地私钥签名，最后base64编码             |

> 拼接参数后得到，ws://server.com/openw/s/v1?a=0102030405&n=123&t=1528520843&c=aes-128-ctr&s=Qwslwws

### 3.3 数据包结构

本协议传输数据，格式编码采用json。消息接收与发送，都遵循数据包规范定义字段内容。

| 参数名 | 类型   | 示例             | 描述                                                                              |
|--------|--------|------------------|-----------------------------------------------------------------------------------|
| r      | uint8  | 1                | 传输类型，1：请求，2：响应                                                            |
| m      | string | subscribe        | 方法名，对应接口方法定义                                                           |
| n      | uint32 | 123              | 请求序号。为了保证请求对应响应按序执行，并防御重放攻击，序号可以为随机数，但不可重复。 |
| t      | uint32 | 1528520843       | 时间戳。限制请求在特定时间范围内有效，如10分钟。                                     |
| d      | Object | {"foo": "hello"} | 数据主体，请求内容或响应内容。接口方法说明中，主要说明这部分。                        |
| s[弃用]      | string | Qwse==           | 合并[r+m+n+t+d]进行sha256两次签名并base64编码，用于校验数据的一致性和合法性       |

### 3.4 响应结果

| 参数名 | 类型   | 示例             | 描述                        |
|--------|--------|------------------|-----------------------------|
| status | uint32 | 200              | 状态码，具体查看OWTP状态说明 |
| msg    | string | success          | 状态描述                    |
| result | Object | {"foo": "hello"} | 数据主体                    |

**请求实例**

```json

{
    "r": 1,
    "m": "subscribe",
    "n": 2290,
    "t": 1528520843,
    "d": {
        "foo": "hello"
    },
    // "s": "Qwse=="
}

```

请求数据包的d内部的json对象就是请求参数，如：参数`foo`=hello。

**响应实例**

```json

{
    "t": 2,
    "m": "subscribe",
    "n": 2290,
    "t": 1528520843,
    "d": {
        "status": 0,
        "msg": "success",
        "result": {
            "txid": "12323123"
        }
    },
    // "s": "Qwse=="
}

```

### 3.4 OWTP状体码说明

| 状态值            | 状态描述                 | 说明                                                                                       |
|-------------------|--------------------------|--------------------------------------------------------------------------------------------|
| **成功状态**      |                          |                                                                                            |
| 200               | success                  | 处理成功                                                                                   |
| **4xx客户端错误** |                          |                                                                                            |
| 400               | bad request              | 由于明显的客户端错误                                                                       |
| 401               | unauthorized             | 授权认证未通过                                                                             |
| 404               | method not found         | 没找到方法                                                                                 |
| 408               | request timeout          | 请求超时                                                                                   |
| 409               | conflict                 | 表示因为请求存在冲突无法处理该请求，可能是重放攻击                                          |
| 413               | request entity too large | 表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。 |
| 429               | too many requests        | 用户在给定的时间内发送了太多的请求。                                                        |
| **5xx服务器错误** |                          |                                                                                            |
| 500               | Internal Server Error    | 通用错误消息                                                                               |
| 501               | response method differ   | 请求与响应的方法不一致                                                                     |

### 3.5 消息处理步骤

1. 节点接收请求后，通过密钥解密数据。
1. 通过验证，需要缓存请求头字段内容[r,m,n,t,s]，并完成方法m的处理。
1. 封装响应结果，序号n必须对应请求的n，这样调用者匹配上一次请求。最后加密数据，发送给对方，完成一次远程调用。
1. t为当前系统时间，为了防止数据包重放，两端可限制时间间隔i内，数据包不能有重复的n。这样终端在验证时，就可以通过计算本地时间-t是否大于i值，n是否存在来防止数据包重复。
1. 终端可以定时清理本地超时的请求缓存，保证数据不会过大。

## 4. OWTP协议交互图

![OWTP协议交互图](../attachment/png/OWTP协议交互流程!OWTP协议交互流程!OWTP协议交互流程_16.png)